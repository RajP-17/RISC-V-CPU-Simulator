#include <bits/stdc++.h>
using namespace std;

constexpr int ARRAY_SIZE = 256;
constexpr int RAM_BYTES = 4096;
constexpr int ADDR_A = 0x0400;
constexpr int ADDR_B = 0x0800;
constexpr int ADDR_C = 0x0C00;

// Latencies in CPU cycles
constexpr int RV32I_EX_CYC = 1;
constexpr int RV32F_EX_CYC = 5;
constexpr int RAM_LAT_CYC = 2;

// Needed Instructions
enum Op {NOP, LI, FLW, FSW, FADD_S, ADDI, BLT, JAL, HALT};

struct Instr {
Op op = NOP;
int rd=0, rs1=0, rs2=0;
int imm=0;      // immediate or absolute target index for branch/jump
string src;     // optional for debugging
};

// RAM with 2 Ports
struct RAM {
vector<uint8_t> mem;
RAM(): mem(RAM_BYTES, 0) {}

// data port request struct
struct DataReq {
bool pending=false;
bool is_write=false;
uint32_t addr=0;
float wdata=0.0f;
int remaining=0;
float rdata=0.0f;
};
// instr port request struct
struct InstrReq {
bool pending=false;
int instr_index=-1;
int remaining=0;
Instr fetched;
};

DataReq data_port;
InstrReq instr_port;
vector<Instr> *instr_mem = nullptr; // pointer to program instructions (for instruction fetch)

// issue instruction fetch: returns false if port busy
bool issue_instr_fetch(int instr_index) {
if(instr_port.pending) return false;
instr_port.pending = true;
instr_port.instr_index = instr_index;
instr_port.remaining = RAM_LAT_CYC;
return true;
}

// issue data request: returns false if data port busy
bool issue_data_request(bool write, uint32_t addr, float wdata=0.0f) {
if(data_port.pending) return false;
data_port.pending = true;
data_port.is_write = write;
data_port.addr = addr;
data_port.wdata = wdata;
data_port.remaining = RAM_LAT_CYC;
return true;
}

// tick (advance latency). When a request completes, set rdata/fetched.
void tick() {
// instr port
if(instr_port.pending) {
instr_port.remaining--;
if(instr_port.remaining <= 0) {
// return instruction from instr_mem (or NOP if out of range)
if(instr_mem && instr_port.instr_index >= 0 && instr_port.instr_index < (int)instr_mem->size())
instr_port.fetched = (*instr_mem)[instr_port.instr_index];
else {
Instr nop;
nop.op = NOP;
instr_port.fetched = nop;
}
instr_port.pending = false; // ready to be read by Fetch stage
instr_port.remaining = 0;
}
}
// data port
if(data_port.pending) {
data_port.remaining--;
if(data_port.remaining <= 0) {
if(data_port.is_write) {
// write 4 bytes (float) little endian
uint8_t buf[4];
memcpy(buf, &data_port.wdata, 4);
if(data_port.addr + 3 < mem.size()) {
for(int i=0; i<4; i++) mem[data_port.addr + i] = buf[i];
}
} else {
float val = 0.0f;
if(data_port.addr + 3 < mem.size()) {
uint8_t buf[4];
for(int i=0; i<4; i++) buf[i]=mem[data_port.addr + i];
memcpy(&val, buf, 4);
}
data_port.rdata = val;
}
// mark request complete; keep rdata/fetched until CPU reads and clears
data_port.pending = false;
data_port.remaining = 0;
}
}
}

// helper to pre-init arrays
void init_arrays_random() {
random_device rd;
mt19937 gen(rd());
uniform_real_distribution<float> d(0.0f, 10.0f);
for(int i=0; i<ARRAY_SIZE; i++) {
float a = d(gen), b = d(gen);
uint8_t buf[4];
memcpy(buf,&a,4);
for(int j=0; j<4; j++) mem[ADDR_A + 4*i + j] = buf[j];
memcpy(buf,&b,4);
for(int j=0; j<4; j++) mem[ADDR_B + 4*i + j] = buf[j];
}
}
};

// Pipeline registers for each stage
struct IF_ID {
bool valid=false;
int pc=-1;
Instr ins;
bool instr_ready=false;
}; // Fetch -> Decode

struct ID_EX {
bool valid=false;
int pc=-1;
Instr ins;
uint32_t rs1_val=0;
uint32_t rs2_val=0;
float frs1_val=0.0f;
float frs2_val=0.0f;
float frd_val=0.0f;  // For FSW
};                         // Decode -> Execute

struct EX_MEM {
bool valid=false;
int pc=-1;
Instr ins;
int ex_remaining=0;
float alu_result=0.0f;
bool mem_requested=false;
bool mem_is_load=false;
uint32_t mem_addr=0;
float mem_wdata=0.0f;
};// Execute -> Store

struct MEM_WB {
bool valid=false;
int pc=-1;
Instr ins;
float result=0.0f;
bool write_reg=false;
int rd=0;
};// Store -> commit (WB)

// CPU
struct CPU {
uint32_t x[32];
float f[32];
int pc = 0; // program index (instruction index)
unsigned long long cycles = 0;
unsigned long long instr_committed = 0;
bool halted=false;

// register ready cycle: earliest cycle where register is available (for RAW detection)
vector<unsigned long long> int_ready;  // size 32
vector<unsigned long long> fp_ready;   // size 32

// pipeline registers
IF_ID if_id;
ID_EX id_ex;
EX_MEM ex_mem;
MEM_WB mem_wb;

CPU(): int_ready(32,0), fp_ready(32,0) {
memset(x,0,sizeof(x));
for(int i=0; i<32; i++) f[i]=0.0f;
}
};

// Build program
vector<Instr> build_program() {
    vector<Instr> p;
    // Initialize pointers and loop counter
    p.push_back({LI,10,0,0, ADDR_A, "li x10, 0x400"});
    p.push_back({LI,11,0,0, ADDR_B, "li x11, 0x800"});
    p.push_back({LI,12,0,0, ADDR_C, "li x12, 0xC00"});
    p.push_back({LI,13,0,0, 256,     "li x13, 256"});
    p.push_back({LI,14,0,0, 0,       "li x14, 0"});
   
    int loop = p.size();
    // Loop body: flw, fadd.s, fsw, increment pointers/counter
    p.push_back({FLW, 1, 10,0,0,     "flw f1,0(x10)"});
    p.push_back({FLW, 2, 11,0,0,     "flw f2,0(x11)"});
    p.push_back({FADD_S,3,1,2,0,     "fadd.s f3,f1,f2"});
    p.push_back({FSW, 3, 12,0,0,     "fsw f3,0(x12)"});
    p.push_back({ADDI,10,10,0,4,     "addi x10,x10,4"});
    p.push_back({ADDI,11,11,0,4,     "addi x11,x11,4"});
    p.push_back({ADDI,12,12,0,4,     "addi x12,x12,4"});
    p.push_back({ADDI,14,14,0,1,     "addi x14,x14,1"});
    p.push_back({BLT, 0, 14,13, loop,"blt x14,x13,loop"});
   
    // End: restore stack and return (halts)
    int end = p.size();
    p.push_back({JAL,0,0,0,end,      "jal x0,end"}); // halting jump
   
   
    return p;
}


// --- Helper: get EX latency for an instruction ---
int ex_latency(const Instr &ins) {
if(ins.op==FADD_S) return RV32F_EX_CYC;
if(ins.op==FLW || ins.op==FSW) return RV32I_EX_CYC; // address calc
return RV32I_EX_CYC;
}

// --- Simulation driver ---
void simulate_pipeline(vector<Instr> &prog, RAM &ram, CPU &cpu, bool verbose=false) {
    ram.instr_mem = &prog;
    cpu.pc = 0;
    for(int i=0;i<32;i++){ cpu.x[i]=0; cpu.f[i]=0.0f; }
    std::fill(cpu.int_ready.begin(), cpu.int_ready.end(), 0ULL);
    std::fill(cpu.fp_ready.begin(), cpu.fp_ready.end(), 0ULL);

    cpu.halted=false;
    cpu.instr_committed=0;
    cpu.cycles=0;

    unsigned long long cycle = 0;
    unsigned long long max_cycles = 20000000ULL;

    while(!cpu.halted && cpu.pc < (int)prog.size() && cycle < max_cycles) {
        Instr ins = prog[cpu.pc];

        // --- Simulate fetch ---
        cpu.if_id.valid = true;
        cpu.if_id.ins = ins;
        cpu.if_id.pc = cpu.pc;

        // --- Decode stage (just copy instruction) ---
        cpu.id_ex.valid = true;
        cpu.id_ex.ins = ins;
        cpu.id_ex.pc = cpu.pc;

        // --- Execute + Memory + Writeback (all together) ---
        float result = 0.0f;
        bool write_reg = false;
        int rd = ins.rd;

        switch (ins.op) {
            case LI:
                result = ins.imm;
                write_reg = true;
                cpu.cycles += RV32I_EX_CYC;
                break;

            case ADDI:
                result = cpu.x[ins.rs1] + ins.imm;
                write_reg = true;
                cpu.cycles += RV32I_EX_CYC;
                break;

            case FLW: {
                uint32_t addr = cpu.x[ins.rs1] + ins.imm;
                float val = 0.0f;
                if(addr + 3 < ram.mem.size()) {
                    uint8_t buf[4];
                    for(int i=0;i<4;i++) buf[i] = ram.mem[addr+i];
                    memcpy(&val, buf, 4);
                }
                result = val;
                write_reg = true;
                cpu.cycles += RV32I_EX_CYC + RAM_LAT_CYC;
                break;
            }

            case FSW: {
                uint32_t addr = cpu.x[ins.rs1] + ins.imm;
                float val = cpu.f[ins.rd];
                uint8_t buf[4];
                memcpy(buf, &val, 4);
                for(int i=0;i<4;i++) ram.mem[addr+i] = buf[i];
                write_reg = false;
                cpu.cycles += RV32I_EX_CYC + RAM_LAT_CYC;
                break;
            }

            case FADD_S:
                result = cpu.f[ins.rs1] + cpu.f[ins.rs2];
                write_reg = true;
                cpu.cycles += RV32F_EX_CYC;
                break;

            case BLT: {
                int32_t a = (int32_t)cpu.x[ins.rs1];
                int32_t b = (int32_t)cpu.x[ins.rs2];
                if(a < b) cpu.pc = ins.imm - 1; // -1 because pc++ at end
                cpu.cycles += RV32I_EX_CYC;
                break;
            }

            case JAL:
                if(ins.rd == 0 && ins.imm == cpu.pc) {
                    cpu.halted = true;
                } else {
                    cpu.pc = ins.imm - 1;
                }
                cpu.cycles += RV32I_EX_CYC;
                break;

            case HALT:
                cpu.halted = true;
                break;

            default:
                cpu.cycles += 1;
                break;
        }

        // --- Writeback (simulated) ---
        if(write_reg && rd != 0) {
            if(ins.op == LI || ins.op == ADDI)
                cpu.x[rd] = (uint32_t)result;
            else if(ins.op == FADD_S || ins.op == FLW)
                cpu.f[rd] = result;
        }

        // Commit
        cpu.mem_wb.valid = true;
        cpu.mem_wb.ins = ins;
        cpu.instr_committed++;

        cpu.pc++;
    }

    if(cycle >= max_cycles)
        cerr << "Simulation exceeded max cycles\n";
}


// Simple reference to validate results
void vadd_reference(RAM &ram_ref) {
for(int i=0; i<ARRAY_SIZE; i++) {
uint8_t buf[4];
memcpy(buf, &ram_ref.mem[ADDR_A + 4*i], 4);
float a;
memcpy(&a, buf, 4);
memcpy(buf, &ram_ref.mem[ADDR_B + 4*i], 4);
float b;
memcpy(&b, buf, 4);
float c = a + b;
memcpy(buf, &c, 4);
for(int j=0; j<4; j++) ram_ref.mem[ADDR_C + 4*i + j] = buf[j];
}
}

//  Utility to print sample outputs
float read_float_from_ram(RAM &ram, int addr) {
float v=0;
if(addr+3 < (int)ram.mem.size()) {
uint8_t buf[4];
for(int i=0; i<4; i++) buf[i]=ram.mem[addr+i];
memcpy(&v,buf,4);
}
return v;
}

// --- Generate assembly with Stack Pointer
string generate_assembly_with_sp() {
ostringstream s;
s << "\t.text\n\t.global main\nmain:\n";
s << "\taddi sp, sp, -16\n\tsw ra, 12(sp)\n\tsw s0, 8(sp)\n\taddi s0, sp, 16\n";
s << "\tli x10, 0x400\t# base A\n\tli x11, 0x800\t# base B\n\tli x12, 0xC00\t# base C\n\tli x13, 256\t# count\n\tli x14, 0\t# i=0\n\nloop:\n";
s << "\tflw f1, 0(x10)\n\tflw f2, 0(x11)\n\tfadd.s f3, f1, f2\n\tfsw f3, 0(x12)\n\taddi x10, x10, 4\n\taddi x11, x11, 4\n\taddi x12, x12, 4\n\taddi x14, x14, 1\n\tblt x14, x13, loop\n\nend:\n\tjal x0, end\n";
s << "\n# stack restore\n\tlw s0, 8(sp)\n\tlw ra, 12(sp)\n\taddi sp, sp, 16\n\tret\n";
return s.str();
}

// Main
int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// Build program and RAM
auto prog = build_program();
RAM ram;
ram.init_arrays_random();
   
// Save a copy for reference validation later
RAM ram_reference = ram;

// CPU
CPU cpu;

// Run pipelined simulation
cout << "Starting pipelined simulation...\n";
simulate_pipeline(prog, ram, cpu, false);

cout << "Simulation completed.\n";
cout << "Cycles (CPU cycles): " << cpu.cycles << "\n";
cout << "Instructions committed: " << cpu.instr_committed << "\n";
double cpi = (cpu.instr_committed>0) ? (double)cpu.cycles / (double)cpu.instr_committed : 0.0;
cout << fixed << setprecision(3);
cout << "Achieved CPI: " << cpi << "\n\n";

// Print some sample results from simulated RAM
cout << "Sample verification (first 8 elements) from simulator RAM:\n";
for(int i=0; i<8; i++) {
float a = read_float_from_ram(ram, ADDR_A + 4*i);
float b = read_float_from_ram(ram, ADDR_B + 4*i);
float c = read_float_from_ram(ram, ADDR_C + 4*i);
cout << "A["<<i<<"]="<<a<<"  B["<<i<<"]="<<b<<"  C["<<i<<"]="<<c<<"\n";
}
cout << "\n";

// Independent reference run
vadd_reference(ram_reference);

// Compare memory C between simulator and reference
bool ok = true;
for(int i=0; i<ARRAY_SIZE; i++) {
float csim = read_float_from_ram(ram, ADDR_C + 4*i);
float cref = read_float_from_ram(ram_reference, ADDR_C + 4*i);
// compare bitwise float equality
if(memcmp(&csim,&cref,4) != 0) {
ok=false;
break;
}
}
   
cout << "Reference vadd ran independently. Verification: " << (ok ? "PASS" : "FAIL") << "\n\n";
cout << "Generated RISC-V assembly (uses stack pointer, saved to vadd_sp.s):\n";
cout << "---------------------------------------------------------------\n";
cout << generate_assembly_with_sp() << "\n";
cout << "---------------------------------------------------------------\n\n";

return 0;
} this is my friends code and here's the output he got Starting pipelined simulation...
Simulation completed.
Cycles (CPU cycles): 4870
Instructions committed: 2310
Achieved CPI: 2.108

Sample verification (first 8 elements) from simulator RAM:
A[0]=6.754  B[0]=9.930  C[0]=16.684
A[1]=5.156  B[1]=2.910  C[1]=8.066
A[2]=1.502  B[2]=9.627  C[2]=11.129
A[3]=2.501  B[3]=8.972  C[3]=11.473
A[4]=0.597  B[4]=2.483  C[4]=3.080
A[5]=2.922  B[5]=5.759  C[5]=8.681
A[6]=0.604  B[6]=9.869  C[6]=10.474
A[7]=1.194  B[7]=5.886  C[7]=7.080

Reference vadd ran independently. Verification: PASS

Generated RISC-V assembly (uses stack pointer, saved to vadd_sp.s):
---------------------------------------------------------------
        .text
        .global main
main:
        addi sp, sp, -16
        sw ra, 12(sp)
        sw s0, 8(sp)
        addi s0, sp, 16
        li x10, 0x400   # base A
        li x11, 0x800   # base B
        li x12, 0xC00   # base C
        li x13, 256     # count
        li x14, 0       # i=0

loop:
        flw f1, 0(x10)
        flw f2, 0(x11)
        fadd.s f3, f1, f2
        fsw f3, 0(x12)
        addi x10, x10, 4
        addi x11, x11, 4
        addi x12, x12, 4
        addi x14, x14, 1
        blt x14, x13, loop

end:
        jal x0, end

# stack restore
        lw s0, 8(sp)
        lw ra, 12(sp)
        addi sp, sp, 16
        ret

---------------------------------------------------------------